{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///D:/Hack-the-Thread-Social-Saver-Bot-Prototype/lib/db.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\"\r\n\r\nconst globalForPrisma = globalThis as unknown as { prisma: PrismaClient | undefined }\r\n\r\nexport const prisma =\r\n  globalForPrisma.prisma ??\r\n  new PrismaClient({\r\n    log: process.env.NODE_ENV === \"development\" ? [\"error\", \"warn\"] : [\"error\"],\r\n  })\r\n\r\nif (process.env.NODE_ENV !== \"production\") globalForPrisma.prisma = prisma\r\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,kBAAkB;AAEjB,MAAM,SACX,gBAAgB,MAAM,IACtB,IAAI,sMAAY,CAAC;IACf,KAAK,uCAAyC;QAAC;QAAS;KAAO,GAAG;AACpE;AAEF,wCAA2C,gBAAgB,MAAM,GAAG"}},
    {"offset": {"line": 64, "column": 0}, "map": {"version":3,"sources":["file:///D:/Hack-the-Thread-Social-Saver-Bot-Prototype/lib/auth.ts"],"sourcesContent":["import { cookies } from \"next/headers\"\r\nimport { prisma } from \"@/lib/db\"\r\n\r\n// ── Types ────────────────────────────────────────────────────────────────\r\nexport interface User {\r\n  id: string\r\n  identifier: string\r\n  type: \"email\" | \"phone\"\r\n  createdAt: string\r\n}\r\n\r\nexport interface Session {\r\n  id: string\r\n  userId: string\r\n  expiresAt: number\r\n}\r\n\r\nconst SESSION_COOKIE = \"social-saver-session\"\r\nconst OTP_TTL_MS = 5 * 60 * 1000 // 5 minutes\r\nconst SESSION_TTL_MS = 24 * 60 * 60 * 1000 // 24 hours\r\n\r\n// ── OTP ──────────────────────────────────────────────────────────────────\r\nexport async function generateOtp(identifier: string): Promise<string> {\r\n  const code = String(Math.floor(100000 + Math.random() * 900000))\r\n  const expiresAt = new Date(Date.now() + OTP_TTL_MS)\r\n\r\n  await prisma.otp.upsert({\r\n    where: { identifier },\r\n    create: { identifier, code, expiresAt },\r\n    update: { code, expiresAt },\r\n  })\r\n\r\n  return code\r\n}\r\n\r\nexport async function verifyOtp(identifier: string, code: string): Promise<boolean> {\r\n  const row = await prisma.otp.findUnique({ where: { identifier } })\r\n  if (!row) return false\r\n  if (new Date() > row.expiresAt) {\r\n    await prisma.otp.delete({ where: { identifier } }).catch(() => {})\r\n    return false\r\n  }\r\n  if (row.code !== code) return false\r\n  await prisma.otp.delete({ where: { identifier } })\r\n  return true\r\n}\r\n\r\n// ── Users ────────────────────────────────────────────────────────────────\r\nexport async function findOrCreateUser(\r\n  identifier: string,\r\n  type: \"email\" | \"phone\"\r\n): Promise<User> {\r\n  const existing = await prisma.user.findUnique({\r\n    where: { identifier },\r\n  })\r\n  if (existing) {\r\n    return toUser(existing)\r\n  }\r\n\r\n  const user = await prisma.user.create({\r\n    data: { identifier, type },\r\n  })\r\n  return toUser(user)\r\n}\r\n\r\nexport async function getUserById(id: string): Promise<User | undefined> {\r\n  const user = await prisma.user.findUnique({ where: { id } })\r\n  return user ? toUser(user) : undefined\r\n}\r\n\r\nfunction toUser(row: { id: string; identifier: string; type: string; createdAt: Date }): User {\r\n  return {\r\n    id: row.id,\r\n    identifier: row.identifier,\r\n    type: row.type as \"email\" | \"phone\",\r\n    createdAt: row.createdAt.toISOString(),\r\n  }\r\n}\r\n\r\n// ── Sessions ─────────────────────────────────────────────────────────────\r\nexport async function createSession(userId: string): Promise<Session> {\r\n  const expiresAt = new Date(Date.now() + SESSION_TTL_MS)\r\n  const session = await prisma.session.create({\r\n    data: { userId, expiresAt },\r\n  })\r\n  return {\r\n    id: session.id,\r\n    userId: session.userId,\r\n    expiresAt: expiresAt.getTime(),\r\n  }\r\n}\r\n\r\nexport async function getSession(sessionId: string): Promise<Session | null> {\r\n  const session = await prisma.session.findUnique({\r\n    where: { id: sessionId },\r\n  })\r\n  if (!session) return null\r\n  if (new Date() > session.expiresAt) {\r\n    await prisma.session.delete({ where: { id: sessionId } }).catch(() => {})\r\n    return null\r\n  }\r\n  return {\r\n    id: session.id,\r\n    userId: session.userId,\r\n    expiresAt: session.expiresAt.getTime(),\r\n  }\r\n}\r\n\r\nexport async function deleteSession(sessionId: string): Promise<void> {\r\n  await prisma.session.delete({ where: { id: sessionId } }).catch(() => {})\r\n}\r\n\r\n// ── Session + Cookie helpers for route handlers ──────────────────────────\r\nexport async function getAuthenticatedUser(): Promise<{\r\n  user: User\r\n  session: Session\r\n} | null> {\r\n  const cookieStore = await cookies()\r\n  const sessionId = cookieStore.get(SESSION_COOKIE)?.value\r\n  if (!sessionId) return null\r\n\r\n  const session = await getSession(sessionId)\r\n  if (!session) return null\r\n\r\n  const user = await getUserById(session.userId)\r\n  if (!user) return null\r\n\r\n  return { user, session }\r\n}\r\n\r\nexport function getSessionCookieName(): string {\r\n  return SESSION_COOKIE\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 230, "column": 0}, "map": {"version":3,"sources":["file:///D:/Hack-the-Thread-Social-Saver-Bot-Prototype/app/api/clear-whatsapp/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\"\r\nimport { getAuthenticatedUser } from \"@/lib/auth\"\r\n\r\nexport async function POST(request: NextRequest) {\r\n    const auth = await getAuthenticatedUser()\r\n    if (!auth) {\r\n        return NextResponse.json({ error: \"Unauthorized\" }, { status: 401 })\r\n    }\r\n\r\n    const workerUrl = process.env.WHATSAPP_WORKER_URL || \"http://localhost:3001\"\r\n\r\n    try {\r\n        const res = await fetch(`${workerUrl}/clear-queue`, {\r\n            method: \"POST\"\r\n        });\r\n\r\n        if (!res.ok) {\r\n            throw new Error(\"Failed to clear worker queue\");\r\n        }\r\n\r\n        const data = await res.json();\r\n        return NextResponse.json({ message: \"Queue cleared\", details: data }, { status: 200 })\r\n    } catch (error) {\r\n        console.error(error);\r\n        return NextResponse.json(\r\n            { error: \"Internal server error connecting to worker\" },\r\n            { status: 500 }\r\n        )\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,eAAe,KAAK,OAAoB;IAC3C,MAAM,OAAO,MAAM,IAAA,qIAAoB;IACvC,IAAI,CAAC,MAAM;QACP,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAe,GAAG;YAAE,QAAQ;QAAI;IACtE;IAEA,MAAM,YAAY,QAAQ,GAAG,CAAC,mBAAmB,IAAI;IAErD,IAAI;QACA,MAAM,MAAM,MAAM,MAAM,GAAG,UAAU,YAAY,CAAC,EAAE;YAChD,QAAQ;QACZ;QAEA,IAAI,CAAC,IAAI,EAAE,EAAE;YACT,MAAM,IAAI,MAAM;QACpB;QAEA,MAAM,OAAO,MAAM,IAAI,IAAI;QAC3B,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,SAAS;YAAiB,SAAS;QAAK,GAAG;YAAE,QAAQ;QAAI;IACxF,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC;QACd,OAAO,gJAAY,CAAC,IAAI,CACpB;YAAE,OAAO;QAA6C,GACtD;YAAE,QAAQ;QAAI;IAEtB;AACJ"}}]
}